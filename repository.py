import sys
import pymongo
import time
import pika


connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))
channel = connection.channel()

#declare/initialize all the exchanges and queues
channel.exchange_declare(exchange="Squires", exchange_type='direct', durable = True)
channel.exchange_declare(exchange="Goodwin", exchange_type='direct', durable = True)
channel.exchange_declare(exchange="Library", exchange_type='direct', durable = True)
channel.queue_declare(queue="Food", durable = True)
channel.queue_declare(queue="Meetings", durable = True)
channel.queue_declare(queue="Rooms", durable = True)
channel.queue_declare(queue="Classrooms", durable = True)
channel.queue_declare(queue="Auditorium", durable = True)
channel.queue_declare(queue="Noise", durable = True)
channel.queue_declare(queue="Seating", durable = True)
channel.queue_declare(queue="Wishes", durable = True)

#bind the queues to the appropriate exchanges
channel.queue_bind(exchange="Squires", queue="Food", routing_key="Food")
channel.queue_bind(exchange="Squires", queue="Meetings", routing_key="Meetings")
channel.queue_bind(exchange="Squires", queue="Rooms", routing_key="Rooms")
channel.queue_bind(exchange="Goodwin", queue="Classrooms", routing_key="Classrooms")
channel.queue_bind(exchange="Goodwin", queue="Auditorium", routing_key="Auditorium")
channel.queue_bind(exchange="Library", queue="Noise", routing_key="Noise")
channel.queue_bind(exchange="Library", queue="Seating", routing_key="Seating")
channel.queue_bind(exchange="Library", queue="Wishes", routing_key="Wishes")

#Gets database ready for insertions
db  =  pymongo.MongoClient().test
global subjBook
subjBook = { "Food":0, "Meetings":0, "Rooms":0, "Classrooms":0, "Auditorium":0, "Noise":0, "Seating":0, "Wishes":0}
while True:
    #Getting command and message from user
    data = input("\nEnter your command: ")

    #Separates the given input into different pieces
    command = data.split(':')[0]
    exchangequeue = data.split(':')[1].split(' ')[0]
    place = exchangequeue.split('+')[0]
    subject = exchangequeue.split('+')[1]
    msgID = "18$" + str(time.time())

    #Checkpoint that informs user command has successfully been collected
    print("[Checkpoint 01 Timestamp] Message Captured: ", data)




    if(command == "p"):
        #If a produce command has been given
        messagebody = data.split('"')[1]
        stats  = {"Action" : command, "Place" : place, "Msg_ID" : msgID, "Subject" : subject, "Message" : messagebody}
        #Add command to database and inform user of the addition
        db.utilization.insert(stats)
        print("[Checkpoint 02 Timestamp] Store command in MongoDB instance: ", stats)

        #increment number of messages in the queue, add to queue, then inform user of addition
        subjBook[subject] += 1
        channel.basic_publish(exchange=place,routing_key=subject,body=messagebody)
        print("[Checkpoint 03 Timestamp] Repository RPi prints statements generated by the RabbitMQ instance: Produce message = ", messagebody)

    elif(command == "c"):
        #If a consume command has been given
        stats  = {"Action" : command, "Place" : place, "Msg_ID" : msgID, "Subject" : subject}
        qn = str(subject)
        #Add to the database and inform user of the addition
        db.utilization.insert(stats)
        print("[Checkpoint 02 Timestamp] Store command in MongoDB instance: ", stats)

        #callback function checks if the queue has messages and if it does, prints all of them
        def callback(ch, method, properties, body):
            print("[Checkpoint 03 Timestamp] Repository RPi prints statements generated by the RabbitMQ instance: Consume message = ", body.decode("utf-8"))
            subjBook[subject]-=1
            if(subjBook[subject] < 1):
                ch.stop_consuming()

        channel.basic_consume(queue=qn, on_message_callback=callback, auto_ack=True)
        if(subjBook[subject] > 0):
            channel.start_consuming()
        else:
            print("[Checkpoint 03 Timestamp] Repository RPi prints statements generated by the RabbitMQ instance: Consume message = NONE")

    else:
        print("Something went wrong")
        sys.exit()

conection.close()





